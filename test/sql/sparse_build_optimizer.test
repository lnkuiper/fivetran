# name: test/sql/sparse_build_optimizer.test
# description: test the SparseBuildOptimizer
# group: [sql]

require fivetran

statement ok
create macro maybe_null(c, p) as
case when random() < p then c else null end

statement ok
create macro input_data(nrow, pnonnull) as table (
    with cte as (
        select
            range pk,
            random() as double_col_0,
            random() as double_col_1,
            random() as double_col_2,
            random() as double_col_3,
            random() as double_col_4,
            hash(random()) as long_col_0,
            hash(random()) as long_col_1,
            hash(random()) as long_col_2,
            hash(random()) as long_col_3,
            hash(random()) as long_col_4,
            'longstring' || hash(random()) as string_col_0,
            'longstring' || hash(random()) as string_col_1,
            'longstring' || hash(random()) as string_col_2,
            'longstring' || hash(random()) as string_col_3,
            'longstring' || hash(random()) as string_col_4,
        from
            range(nrow)
    )
    select maybe_null(columns(*), pnonnull) as "\0"
    from cte
)

# quick check that struct_to_sparse_variant can handle this input
statement ok
select struct_to_sparse_variant(id)
from input_data(10, 0.1) id

statement ok
create or replace table build as from input_data(10, 0.1)

statement ok
create or replace table probe as from input_data(10, 1), range(10)

# test each query with and without optimizer enabled, should yield same results
foreach do '' 'extension'

statement ok
set disabled_optimizers to ${do}

query IIIIIIIIIIIIIIII nosort q0
select
    p.pk,
    coalesce(b.double_col_0, p.double_col_0),
    coalesce(b.double_col_1, p.double_col_1),
    coalesce(b.double_col_2, p.double_col_2),
    coalesce(b.double_col_3, p.double_col_3),
    coalesce(b.double_col_4, p.double_col_4),
    coalesce(b.long_col_0, p.long_col_0),
    coalesce(b.long_col_1, p.long_col_1),
    coalesce(b.long_col_2, p.long_col_2),
    coalesce(b.long_col_3, p.long_col_3),
    coalesce(b.long_col_4, p.long_col_4),
    coalesce(b.string_col_0, p.string_col_0),
    coalesce(b.string_col_1, p.string_col_1),
    coalesce(b.string_col_2, p.string_col_2),
    coalesce(b.string_col_3, p.string_col_3),
    coalesce(b.string_col_4, p.string_col_4),
from probe p
left join build b
using (pk)
order by all
----


endloop
