# name: test/sql/sparse_build_optimizer.test
# description: test the SparseBuildOptimizer
# group: [sql]

require fivetran

statement ok
create macro maybe_null(c, p) as
case when random() < p then c else null end

statement ok
create macro input_data(nrow, pnonnull) as table (
    with cte as (
        select
            range pk,
            random() as double_col_0,
            random() as double_col_1,
            random() as double_col_2,
            random() as double_col_3,
            random() as double_col_4,
            hash(random()) as long_col_0,
            hash(random()) as long_col_1,
            hash(random()) as long_col_2,
            hash(random()) as long_col_3,
            hash(random()) as long_col_4,
            'longstring' || hash(random()) as string_col_0,
            'longstring' || hash(random()) as string_col_1,
            'longstring' || hash(random()) as string_col_2,
            'longstring' || hash(random()) as string_col_3,
            'longstring' || hash(random()) as string_col_4,
        from
            range(nrow)
    )
    select maybe_null(columns(*), pnonnull) as "\0"
    from cte
)

# quick check that struct_to_sparse_variant can handle this input
statement ok
select struct_to_sparse_variant(id)
from input_data(10, 0.1) id

statement ok
create or replace table build as from input_data(10, 0.1)

statement ok
create or replace table probe as from input_data(10, 1), range(30)

# test that the optimization is triggered by inspecting the plan
statement ok
PRAGMA explain_output = 'OPTIMIZED_ONLY'

query II
explain select
    p.pk,
    coalesce(b.double_col_0, p.double_col_0),
    coalesce(b.double_col_1, p.double_col_1),
    coalesce(b.double_col_2, p.double_col_2),
    coalesce(b.double_col_3, p.double_col_3),
    coalesce(b.double_col_4, p.double_col_4),
    coalesce(b.long_col_0, p.long_col_0),
    coalesce(b.long_col_1, p.long_col_1),
    coalesce(b.long_col_2, p.long_col_2),
    coalesce(b.long_col_3, p.long_col_3),
    coalesce(b.long_col_4, p.long_col_4),
    coalesce(b.string_col_0, p.string_col_0),
    coalesce(b.string_col_1, p.string_col_1),
    coalesce(b.string_col_2, p.string_col_2),
    coalesce(b.string_col_3, p.string_col_3),
    coalesce(b.string_col_4, p.string_col_4),
from probe p
left join build b
using (pk)
order by all
----
logical_opt	<REGEX>:.*struct_to_sparse_variant.*

# test each query with and without optimizer enabled, should yield same results
foreach threshold -1 0

statement ok
set fivetran_sparse_build_optimizer_column_threshold to ${threshold}

# this tests with/without projection maps
foreach do '' 'column_lifetime'

statement ok
set disabled_optimizers to ${do}

# test with a bunch of different column combinations
query IIIIIIIIIIIIIIII nosort q0
select
    p.pk,
    coalesce(b.double_col_0, p.double_col_0),
    coalesce(b.double_col_1, p.double_col_1),
    coalesce(b.double_col_2, p.double_col_2),
    coalesce(b.double_col_3, p.double_col_3),
    coalesce(b.double_col_4, p.double_col_4),
    coalesce(b.long_col_0, p.long_col_0),
    coalesce(b.long_col_1, p.long_col_1),
    coalesce(b.long_col_2, p.long_col_2),
    coalesce(b.long_col_3, p.long_col_3),
    coalesce(b.long_col_4, p.long_col_4),
    coalesce(b.string_col_0, p.string_col_0),
    coalesce(b.string_col_1, p.string_col_1),
    coalesce(b.string_col_2, p.string_col_2),
    coalesce(b.string_col_3, p.string_col_3),
    coalesce(b.string_col_4, p.string_col_4),
from probe p
left join build b
using (pk)
order by all
----

query IIIIIIIIIIIIIIII nosort q1
select
    p.pk,
    b.double_col_0,
    p.double_col_1,
    b.double_col_2,
    p.double_col_3,
    b.double_col_4,
    p.long_col_0,
    b.long_col_1,
    p.long_col_2,
    b.long_col_3,
    p.long_col_4,
    b.string_col_0,
    p.string_col_1,
    b.string_col_2,
    p.string_col_3,
    b.string_col_4,
from probe p
left join build b
using (pk)
order by all
----

query IIIIIIIIIIIIIIII nosort q2
select
    p.pk,
    b.double_col_0,
    b.double_col_1,
    b.double_col_2,
    b.double_col_3,
    b.double_col_4,
    b.long_col_0,
    b.long_col_1,
    b.long_col_2,
    b.long_col_3,
    b.long_col_4,
    b.string_col_0,
    b.string_col_1,
    b.string_col_2,
    b.string_col_3,
    b.string_col_4,
from probe p
left join build b
using (pk)
order by all
----

endloop

endloop
